
/** required package class namespace */
package movement1;

/** required imports */
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;


/**
 * UserInterface.java - This is the "level 1" gaming movement example which 
 * uses the NetBeans designer to help with building a layout quicker and 
 * without much coding. It also keeps all the code in this class and doesn't 
 * use any other classes. This has some advantages, but does make for longer 
 * and less flexible code. I try to keep the code simple, it reduces the things 
 * this project can do, but keeps the complexity (and the math) a lot 
 * simpler. 
 * 
 * THE DESIGN
 * ==========
 * 
 * The designer is used and a number of JLabels are added and the properties 
 * of each are set to have an etched border, horizontal alignment set to 
 * center, opaque set to true, and a background color and/or text added. I also
 * recommend if doing a project this way, you should take the time to right
 * click every label and go to "Change Variable Name" and name each label
 * so that it is easier to identify them in code later.
 * 
 * THE CODE
 * ========
 * The code can be found below. You also need to right click the JFrame (form)
 * and go to Events -> Key -> KeyPressed to access the method for key press
 * actions. I have tried to comment the code to explain what it does.
 *
 * @author Mr. Wachs
 * @since Jan. 7, 2020, 1:44:34 p.m.
 */
public class UserInterface extends javax.swing.JFrame 
{

    // GLOBAL VARIABLES:
    // =================
    // We need several global variables for moving objects around. Since we
    // need to get the "coordinates" of where our moving object (the hero) is
    // at this moment, so we need some data from it's geometery. We use a 
    // coordinate system like in math class using the Cartesian geometry 
    // plane. However in Java, the plane is "flipped" and the "origin point" 
    // of (0,0) is in the top left corner and the values of "y" go up in 
    // value when moving down from here (which is opposite from math class), 
    // but "x" values behave as normal.
    
    // Some constants to use names for the direction values
    final int LEFT   = 1;
    final int RIGHT  = 2;
    final int UP     = 3;
    final int DOWN   = 4;
    final int STOP   = 0;
    final int AMOUNT = 20;
    
    // A direction variable for the hero to track which direction it is going
    int direction = STOP;
    
    // This special imported class Rectangle (use the lightbulb to import) to  
    // store values for the hero from the hero label's coordinate values
    Rectangle heroHitbox = new Rectangle();
    

    /** 
     * Default constructor, creates new form UserInterface 
     */
    public UserInterface() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        wallRight = new javax.swing.JLabel();
        objective = new javax.swing.JLabel();
        wallTop = new javax.swing.JLabel();
        wallBottom = new javax.swing.JLabel();
        wallLeft = new javax.swing.JLabel();
        hero = new javax.swing.JLabel();
        enemy = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 255, 255));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        wallRight.setBackground(new java.awt.Color(102, 153, 255));
        wallRight.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        wallRight.setText("WALL");
        wallRight.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        wallRight.setOpaque(true);

        objective.setBackground(new java.awt.Color(255, 255, 51));
        objective.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        objective.setText("OBJECTIVE");
        objective.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        objective.setOpaque(true);

        wallTop.setBackground(new java.awt.Color(102, 153, 255));
        wallTop.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        wallTop.setText("WALL");
        wallTop.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        wallTop.setOpaque(true);

        wallBottom.setBackground(new java.awt.Color(102, 153, 255));
        wallBottom.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        wallBottom.setText("WALL");
        wallBottom.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        wallBottom.setOpaque(true);

        wallLeft.setBackground(new java.awt.Color(102, 153, 255));
        wallLeft.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        wallLeft.setText("WALL");
        wallLeft.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        wallLeft.setOpaque(true);

        hero.setBackground(new java.awt.Color(0, 204, 0));
        hero.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        hero.setText("HERO");
        hero.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        hero.setOpaque(true);

        enemy.setBackground(new java.awt.Color(255, 51, 51));
        enemy.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        enemy.setText("ENEMY");
        enemy.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        enemy.setOpaque(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(100, 100, 100)
                .addComponent(hero, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(196, 196, 196)
                .addComponent(enemy, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(wallBottom, javax.swing.GroupLayout.PREFERRED_SIZE, 500, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(wallTop, javax.swing.GroupLayout.PREFERRED_SIZE, 500, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(wallLeft, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(159, 159, 159)
                .addComponent(objective, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(178, 178, 178)
                .addComponent(wallRight, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(100, 100, 100)
                        .addComponent(hero, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(wallTop, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(36, 36, 36)
                        .addComponent(enemy, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(138, 138, 138)
                .addComponent(objective, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(wallBottom, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(wallLeft, javax.swing.GroupLayout.PREFERRED_SIZE, 410, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(wallRight, javax.swing.GroupLayout.PREFERRED_SIZE, 410, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        
        // Here the logic of all the actions is divided into seperate methods 
        // that can be found further down the code....
        
        // first get the location of the hero at this moment...
        heroHitbox = new Rectangle(hero.getX(), hero.getY(),
                                   hero.getWidth(), hero.getHeight());
        
        // Only perform actions when certain keys are pressed, not any key. We 
        // can use the parameters of this method that was auto generated by 
        // NetBeans. We will also pass the parameter to our own method that 
        // will use it
        moveHero(evt);
        
        // Now we can check for collisions with the objective, and if we
        // "touch" it we win the game. To do this, we also need the 
        // coordinates of the objective.
        
        // Create a second rectangle object from the objective label's
        // current coordinates
        Rectangle objectiveHitbox = new Rectangle(objective.getX(), 
                                                  objective.getY(), 
                                                  objective.getWidth(), 
                                                  objective.getHeight());

        // now use the built-in "intersects" method to determine if the 2 
        // rectangles are overlapping with each other        
        if (heroHitbox.intersects(objectiveHitbox)) {
            // jump to a method to stick to object
            stickTo(objectiveHitbox);
            // redraw the label with it's new coordinates
            hero.setBounds(heroHitbox.x, heroHitbox.y, 
                           heroHitbox.width, heroHitbox.height);
            JOptionPane.showMessageDialog(this, "You win!");
            System.exit(0);
        }
        
        // Now the collison with the enemy, if we "touch" it we lose
        
        // The enemy coordinates stored in a third rectangle object
        Rectangle enemyHitbox = new Rectangle(enemy.getX(), 
                                              enemy.getY(), 
                                              enemy.getWidth(), 
                                              enemy.getHeight());
        
        // check for hitbox collision
        if (heroHitbox.intersects(enemyHitbox)) {
            // jump to a method to stick to object
            stickTo(enemyHitbox);
            // redraw the label with it's new coordinates
            hero.setBounds(heroHitbox.x, heroHitbox.y, 
                           heroHitbox.width, heroHitbox.height);
            JOptionPane.showMessageDialog(this, "You lose!");
            System.exit(0);
        }
        
        // check for walls collision
        checkForCollsionWithWalls();
        
        // Finally, redraw the label with it's new coordinates
        hero.setBounds(heroHitbox.x, heroHitbox.y, 
                       heroHitbox.width, heroHitbox.height);
                
    }//GEN-LAST:event_formKeyPressed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(UserInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(UserInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(UserInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(UserInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UserInterface().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel enemy;
    private javax.swing.JLabel hero;
    private javax.swing.JLabel objective;
    private javax.swing.JLabel wallBottom;
    private javax.swing.JLabel wallLeft;
    private javax.swing.JLabel wallRight;
    private javax.swing.JLabel wallTop;
    // End of variables declaration//GEN-END:variables
    
    /** 
     * Moves the hero's coordinates accordingly, When we move our hero up 1 
     * pixel, so we subtract from y. Similarly other values are adjusted 
     * accordingly.
     * 
     * @param event the keyboard event
     */
    private void moveHero(KeyEvent event) {        
        // The KeyEvent word requires you to use the "lightbulb" to import it
        // the if statement checks which key was pressed and then moves the
        // appropriate coordinate in the appropriate direction and stores the
        // direction as a value
        if (event.getKeyCode() == KeyEvent.VK_UP) {
            heroHitbox.y = heroHitbox.y - AMOUNT;
            direction = UP;
        } 
        else if (event.getKeyCode() == KeyEvent.VK_DOWN) {
            heroHitbox.y = heroHitbox.y + AMOUNT;
            direction = DOWN;
        } 
        else if (event.getKeyCode() == KeyEvent.VK_LEFT) {
            heroHitbox.x = heroHitbox.x - AMOUNT;
            direction = LEFT;
        } 
        else if (event.getKeyCode() == KeyEvent.VK_RIGHT) {
            heroHitbox.x = heroHitbox.x + AMOUNT;
            direction = RIGHT;
        }        
    }    
    
    /**
     * Now the collision with the walls, if we "touch" and of the walls,
     * we will need to reposition the coordinates to now "touch" them any
     * more and not go "through" the wall(s). This code will use an array
     * because there is multiple walls.
     */
    private void checkForCollsionWithWalls() {        
        // Now an array for all the wall label objectss (the JLabel will have 
        // to be imported) and then assign the labels into the array directly
        JLabel[] walls = { wallLeft, wallRight, wallTop, wallBottom };        
        // use a loop to traverse all the walls in the array
        for (int i = 0; i < walls.length; i++) {            
            // the enemy coordinates stored in a rectagle object and the values
            // are retreived from the array of labels
            Rectangle wallHitbox = new Rectangle(walls[i].getX(), 
                                                 walls[i].getY(), 
                                                 walls[i].getWidth(), 
                                                 walls[i].getHeight());             
            // check for hitbox collision with the current wall
            if (heroHitbox.intersects(wallHitbox)) {                 
                // jump to a method to stick to object
                stickTo(wallHitbox);                
                // now exit the loop early
                i = walls.length;                
            }
        }        
    }

    /**
     * We position the hero's hitbox rectangle, because a collision has 
     * occurred, now based on direction, reposition the hero's coordinates
     * just outside the object's rectangle just hit
     * 
     * @param hitbox the coordinates of the object just hit
     */
    private void stickTo(Rectangle hitbox) { 
        if (direction == LEFT) {
            heroHitbox.x = hitbox.x + hitbox.width + 1; 
        }
        else if (direction == RIGHT) {
            heroHitbox.x = hitbox.x - heroHitbox.width - 1; 
        }
        else if (direction == DOWN) {
            heroHitbox.y = hitbox.y - heroHitbox.height - 1; 
        }            
        else if (direction == UP) {
            heroHitbox.y = hitbox.y + hitbox.height + 1; 
        }        
    }

}
